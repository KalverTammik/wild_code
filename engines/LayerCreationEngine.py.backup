#!/usr/bin/env python3
"""
Layer Creation Engine for Mailabl QGIS Plugin

This engine provides comprehensive layer management services including:
- Memory layer creation and management
- GeoPackage persistence
- Layer group organization
- Virtual layer copying for properties

Author: Wild Code Plugin Team
Date: September 3, 2025
"""

import os
from typing import Optional, Dict, Any, List
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsLayerTreeGroup, QgsLayerTreeRoot,
    QgsVectorFileWriter, QgsCoordinateReferenceSystem, QgsFields,
    QgsFeature, QgsGeometry, Qgis
)
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
from qgis.PyQt.QtCore import QTimer


class MailablGroupFolders:
    """Standard group folder names for Mailabl plugin."""

    MAILABL_MAIN = "Mailabl settings"
    NEW_PROPERTIES = "Uued kinnistud"
    SANDBOXING = "Ajutised kihid"
    ARCHIVE = "Arhiiv"
    IMPORT = "Import"
    EXPORT = "Eksport"
    SYNC = "Sünkroonimine"


class LayerCreationEngine:
    """
    Main engine for layer creation and management operations.

    Provides services for:
    - Creating memory layers from templates
    - Managing layer groups
    - Persisting layers to GeoPackage
    - Copying virtual layers for properties
    """

    def __init__(self):
        self.project = QgsProject.instance()
        self.layer_tree_root = self.project.layerTreeRoot()

    def get_or_create_group(self, group_name: str) -> QgsLayerTreeGroup:
        """
        Get existing group or create new one.

        Args:
            group_name: Name of the group to retrieve/create

        Returns:
            QgsLayerTreeGroup: The group object
        """
        # Try to find existing group
        existing_group = self.layer_tree_root.findGroup(group_name)
        if existing_group:
            return existing_group

        # Create new group
        new_group = self.layer_tree_root.addGroup(group_name)
        print(f"[LayerEngine] Created new group: {group_name}")
        return new_group

    def create_memory_layer_from_template(
        self,
        layer_name: str,
        template_layer: Optional[QgsVectorLayer] = None,
        fields: Optional[QgsFields] = None,
        crs: Optional[QgsCoordinateReferenceSystem] = None,
        geometry_type: str = "Point"
    ) -> Optional[QgsVectorLayer]:
        """
        Create a memory layer from template or specifications.

        Args:
            layer_name: Name for the new layer
            template_layer: Optional template layer to copy from
            fields: Optional fields specification
            crs: Optional CRS specification
            geometry_type: Geometry type if no template

        Returns:
            Optional[QgsVectorLayer]: Created memory layer or None if failed
        """
        try:
            # Remove existing layer with same name if it exists
            existing_layer = self.project.mapLayersByName(layer_name)
            for layer in existing_layer:
                if layer.providerType() == 'memory':
                    self.project.removeMapLayer(layer.id())
                    print(f"[LayerEngine] Removed existing memory layer: {layer_name}")

            # Create URI for memory layer
            if template_layer:
                # Copy from template
                uri = template_layer.dataProvider().dataSourceUri()
                new_layer = QgsVectorLayer(uri, layer_name, 'memory')

                # Copy fields and CRS from template
                if template_layer.fields():
                    new_layer.setFields(template_layer.fields())
                if template_layer.crs():
                    new_layer.setCrs(template_layer.crs())

            else:
                # Create from specifications
                uri = f"{geometry_type}?crs={crs.authid() if crs else 'EPSG:3301'}"
                new_layer = QgsVectorLayer(uri, layer_name, 'memory')

                if fields:
                    new_layer.setFields(fields)

            if not new_layer.isValid():
                print(f"[LayerEngine] Failed to create valid memory layer: {layer_name}")
                return None

            # Add to project
            self.project.addMapLayer(new_layer, False)  # Don't add to legend yet
            print(f"[LayerEngine] Created memory layer: {layer_name}")
            return new_layer

        except Exception as e:
            print(f"[LayerEngine] Error creating memory layer: {e}")
            return None

    def copy_virtual_layer_for_properties(
        self,
        new_layer_name: str,
        group_name: str,
        template_layer: Optional[QgsVectorLayer] = None
    ) -> Optional[str]:
        """
        Create a virtual copy of a layer for property operations.

        Args:
            new_layer_name: Name for the new layer
            group_name: Target group name
            template_layer: Optional template layer

        Returns:
            Optional[str]: Name of created layer or None if failed
        """
        try:
            # Get or create group
            group = self.get_or_create_group(group_name)

            # Create memory layer
            memory_layer = self.create_memory_layer_from_template(
                new_layer_name, template_layer
            )

            if not memory_layer:
                return None

            # Add to group
            group.addLayer(memory_layer)
            print(f"[LayerEngine] Added layer '{new_layer_name}' to group '{group_name}'")

            return new_layer_name

        except Exception as e:
            print(f"[LayerEngine] Error copying virtual layer: {e}")
            return None

    def save_memory_layer_to_geopackage(
        self,
        memory_layer_name: str,
        new_layer_name: str,
        group_name: str,
        save_directory: Optional[str] = None
    ) -> bool:
        """
        Save memory layer to GeoPackage and reload into project.

        Args:
            memory_layer_name: Name of memory layer to save
            new_layer_name: Name for saved layer
            group_name: Target group name
            save_directory: Optional save directory

        Returns:
            bool: True if successful
        """
        try:
            # Find memory layer
            memory_layer = None
            for layer in self.project.mapLayers().values():
                if layer.name() == memory_layer_name and layer.providerType() == 'memory':
                    memory_layer = layer
                    break

            if not memory_layer:
                print(f"[LayerEngine] Memory layer not found: {memory_layer_name}")
                return False

            # Get save directory
            if not save_directory:
                save_directory = QFileDialog.getExistingDirectory(
                    None, "Vali salvestuskataloog", os.path.expanduser("~")
                )
                if not save_directory:
                    return False

            # Create file path
            file_path = os.path.join(save_directory, f"{new_layer_name}.gpkg")

            # Handle existing file
            if os.path.exists(file_path):
                reply = QMessageBox.question(
                    None, "Fail on olemas",
                    f"Fail '{file_path}' on juba olemas. Kas kirjutada üle?",
                    QMessageBox.Yes | QMessageBox.No
                )
                if reply == QMessageBox.No:
                    return False
                os.remove(file_path)

            # Save to GeoPackage
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.layerName = new_layer_name

            error = QgsVectorFileWriter.writeAsVectorFormatV3(
                memory_layer, file_path, self.project.transformContext(), options
            )

            if error[0] != Qgis.NoError:
                print(f"[LayerEngine] Error saving to GeoPackage: {error[1]}")
                return False

            print(f"[LayerEngine] Saved layer to: {file_path}")

            # Reload the saved layer
            saved_layer = QgsVectorLayer(file_path, new_layer_name, "ogr")
            if saved_layer.isValid():
                self.project.addMapLayer(saved_layer, False)

                # Add to group
                group = self.get_or_create_group(group_name)
                group.addLayer(saved_layer)

                # Remove memory layer
                self.project.removeMapLayer(memory_layer.id())

                print(f"[LayerEngine] Reloaded layer '{new_layer_name}' into group '{group_name}'")
                return True
            else:
                print(f"[LayerEngine] Failed to reload saved layer: {file_path}")
                return False

        except Exception as e:
            print(f"[LayerEngine] Error saving memory layer: {e}")
            return False

    def create_property_sync_layer(self, base_layer: Optional[QgsVectorLayer] = None) -> Optional[str]:
        """
        Create a layer specifically for property synchronization.

        Args:
            base_layer: Optional base layer to copy from

        Returns:
            Optional[str]: Name of created layer
        """
        layer_name = "PropertySync_Layer"
        group_name = MailablGroupFolders.SYNC

        return self.copy_virtual_layer_for_properties(layer_name, group_name, base_layer)

    def create_archive_layer(self, base_layer: Optional[QgsVectorLayer] = None) -> Optional[str]:
        """
        Create a layer for archiving operations.

        Args:
            base_layer: Optional base layer to copy from

        Returns:
            Optional[str]: Name of created layer
        """
        layer_name = "Archive_Layer"
        group_name = MailablGroupFolders.ARCHIVE

        return self.copy_virtual_layer_for_properties(layer_name, group_name, base_layer)

    def create_import_layer(self, base_layer: Optional[QgsVectorLayer] = None) -> Optional[str]:
        """
        Create a layer for import operations.

        Args:
            base_layer: Optional base layer to copy from

        Returns:
            Optional[str]: Name of created layer
        """
        layer_name = "Import_Layer"
        group_name = MailablGroupFolders.IMPORT

        return self.copy_virtual_layer_for_properties(layer_name, group_name, base_layer)

    def get_available_groups(self) -> List[str]:
        """
        Get list of available layer groups.

        Returns:
            List[str]: List of group names
        """
        groups = []
        for child in self.layer_tree_root.children():
            if isinstance(child, QgsLayerTreeGroup):
                groups.append(child.name())
        return groups

    def get_layers_in_group(self, group_name: str) -> List[QgsVectorLayer]:
        """
        Get all layers in a specific group.

        Args:
            group_name: Name of the group

        Returns:
            List[QgsVectorLayer]: List of layers in the group
        """
        group = self.layer_tree_root.findGroup(group_name)
        if not group:
            return []

        layers = []
        for child in group.children():
            if hasattr(child, 'layer') and child.layer():
                layers.append(child.layer())

        return layers


# Global instance for easy access
_layer_engine_instance = None

def get_layer_engine() -> LayerCreationEngine:
    """Get global layer engine instance."""
    global _layer_engine_instance
    if _layer_engine_instance is None:
        _layer_engine_instance = LayerCreationEngine()
    return _layer_engine_instance</content>
<parameter name="filePath">c:\Users\Kalver\AppData\Roaming\QGIS\QGIS3\profiles\default\python\plugins\wild_code\engines\LayerCreationEngine.py
