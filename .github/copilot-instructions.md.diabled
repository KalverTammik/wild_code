DISABLED: Custom instructions for Copilot in wild_code QGIS Plugin for refractoring and new feature development.

# AI Coding Instructions for wild_code QGIS Plugin

## Project Overview
**wild_code** is a modular QGIS plugin built with PyQt5 that provides property management, project tracking, and contract administration features. It follows a strict modular architecture with centralized resource management.

## Architecture Fundamentals

### Core Components
- **Main Entry Point**: `main.py` - Plugin initialization, authentication flow, module activation
- **UI Framework**: `dialog.py` - Main dialog with sidebar navigation and module stacking
- **Module System**: `BaseModule` inheritance with `activate()`/`deactivate()`/`get_widget()` lifecycle
- **Authentication**: `SessionManager` with QGIS AuthManager integration and GraphQL API client

### Data Flow
1. **Authentication**: Login → SessionManager → API token storage
2. **Module Loading**: PluginDialog → ModuleManager → Sidebar registration
3. **API Calls**: APIClient → GraphQL queries → Session validation
4. **UI Updates**: ThemeManager → QSS application → Module retheming

## Critical Patterns & Conventions

### Module Development
```python
# ✅ CORRECT: All modules inherit from ModuleBaseUI
class NewModule(ModuleBaseUI):
    def __init__(self, lang_manager, theme_manager, qss_files=None, **kwargs):
        super().__init__(lang_manager=lang_manager, theme_manager=theme_manager, qss_files=qss_files, **kwargs)
        self.name = Module.NEW_MODULE.value  # Required: matches constants/module_names.py, set as instance attribute
        self.setup_ui()

    def setup_ui(self):
        # Apply theming immediately
        ThemeManager.apply_module_style(self.widget, [QssPaths.MAIN])
        # Build UI components...

    def activate(self):
        super().activate()  # Required: calls base activation
        # Module-specific activation logic

    def get_widget(self):
        return self.widget  # Must return QWidget instance, never class
```

### Class Definition Rules
- Inherit from `ModuleBaseUI` (the shared base class for UI modules, providing toolbar, feed engine, and theming logic). Avoid inheriting directly from `BaseModule` unless it's an abstract or non-UI module.
- The module must define a unique `name` as an **instance attribute** in the constructor (e.g., `self.name = Module.MY_MODULE.value`). Do not use class-level attributes for `name`, `display_name`, or `icon`.
- The constructor should accept essential managers (e.g., `lang_manager`, `theme_manager`) and other dependencies (e.g., `parent`, `qss_files`). Use `**kwargs` for flexibility to handle future additions without breaking existing code.
- Implement all required methods: `activate` (for lazy loading and initialization), `deactivate` (for cleanup), and `get_widget` (to return the QWidget instance). `run` and `reset` are optional and may be inherited from `ModuleBaseUI` if not overridden.
- Use `lang_manager.translate()` for all user-facing strings. `display_name` and `icon` are typically handled by `ModuleManager` or `ModuleIconPaths` during registration—do not set them manually in the constructor unless overriding defaults.

### Path & Resource Management
```python
# ✅ CORRECT: Never hardcode paths
from .constants.file_paths import QssPaths, ResourcePaths
icon_path = ResourcePaths.ICON
ThemeManager.apply_module_style(widget, [QssPaths.MAIN])

# ❌ WRONG: Direct path construction
icon_path = os.path.join("resources", "icon.png")
```

### Theming Requirements
**HOIATUS: Ära kasuta globaalset stiililehte (QApplication.setStyleSheet)** - KEELATUD: `QApplication.instance().setStyleSheet(...)` või `qApp.setStyleSheet(...)` – see lekib plugina teema kogu QGIS-i UI-sse (toolbarid, paneelid) ja rikub kasutaja teema.

- **Centralized Theme Management**: All theme logic (theme detection, toggling, QSS application) must use the shared `ThemeManager`. All modules and widgets must use `ThemeManager.apply_module_style(widget, [QssPaths.VARIABLE])` for theming. Never hardcode theme logic or QSS paths in individual modules/widgets.
- **QSS File Structure**: All theme-specific QSS files must be placed in `styles/Light/` and `styles/Dark/` folders. Each module/widget with custom styling must have its own QSS file (e.g., `NewModule.qss`).
- **Widget Styling**: Assign a unique `objectName` to any widget that needs custom QSS (e.g., `"NewModule"`). Apply QSS using `ThemeManager.apply_module_style(widget, [QssPaths.VARIABLE])`.
- **Dynamic Restyling**: Modules creating dynamic content must implement retheme methods (e.g., `rethem_module()`) to re-apply QSS. The dialog calls these after theme toggles.
- **Theme Toggle Integration**: The main dialog's `toggle_theme` must call `ThemeManager.toggle_theme()`, re-apply styles to UI, call module retheme methods, and perform a generic sweep for `retheme()` on child widgets.
- **No Direct QSS File Reading**: Do not read QSS files directly in modules. Always use `ThemeManager.apply_module_style`.

```python
# ✅ CORRECT: Centralized theming application
ThemeManager.apply_module_style(self, [QssPaths.MAIN])
ThemeManager.apply_module_style(self, [QssPaths.PILLS, QssPaths.SETUP_CARD])

# ❌ WRONG: Global stylesheet application
QApplication.setStyleSheet("...")  # Breaks QGIS UI
```

### Translation Integration
- Use `LanguageManager` for all translations.
- Translation files must be Python files (`.py`) and placed in the module's `lang/` directory (e.g., `modules/ProjectCard/lang/en.py`).
- Sidebar button names must be defined in `languages/sidebar_button_names_<lang>.py` using string keys matching module class names.
- Use centralized keys from `languages/translation_keys.py` for consistency.

```python
# ✅ CORRECT: Use TranslationKeys for centralized keys
from .languages.translation_keys import TranslationKeys
text = lang_manager.translate(TranslationKeys.SELECT_LAYER)
button_text = lang_manager.sidebar_button("ModuleName")

# ❌ WRONG: Inline strings or hardcoded keys
button.setText("Hardcoded Text")
text = lang_manager.translate("select_layer")
```

### API Communication
```python
# ✅ CORRECT: Always use APIClient
from utils.api_client import APIClient
client = APIClient(lang_manager)
data = client.send_query(query, variables={"id": item_id})

# ❌ WRONG: Direct requests
response = requests.post(url, json=payload)
```

## Module Registration Flow

### 1. Define Module Constant
```python
# constants/module_names.py
NEW_MODULE = "NewModule"
```

### 2. Create Module Structure
```
modules/NewModule/
├── __init__.py
├── NewModuleUI.py    # Main UI class
```

### 3. Register in Dialog
```python
# dialog.py loadModules() method
from .modules.NewModule.NewModuleUI import NewModuleUI
qss_modular = [QssPaths.MAIN, QssPaths.COMBOBOX, QssPaths.SIDEBAR]
module = NewModuleUI(lang_manager=self.lang_manager, theme_manager=self.theme_manager, qss_files=qss_modular)
self.moduleManager.registerModule(module)
```

## Settings Architecture

### Hierarchical Settings Management
- **Theme**: `ThemeManager.save_theme_setting()`
- **Preferred Module**: `SettingsLogic` via QSettings key `"wild_code/preferred_module"`
- **Module-specific**: `ThemeManager.save_module_setting(module_name, key, value)`
- **Utility**: `SettingsManager.save_setting("wild_code/key", value)`

### Layer Selection Pattern
```python
# Use LayerTreePicker for all layer selections
from languages.translation_keys import TranslationKeys
picker = LayerTreePicker(self, placeholder=lang_manager.translate(TranslationKeys.SELECT_LAYER))
picker.layerIdChanged.connect(self.on_layer_changed)
```

## Development Workflow

### Adding New Features
1. **Check existing patterns** in similar modules (Property, Contract, Projects)
2. **Use centralized managers** (ThemeManager, LanguageManager, SettingsManager)
3. **Apply QSS theming** immediately in UI setup
4. **Handle translations** from module-specific lang files
5. **Test with both themes** (Light/Dark) and languages (en/et)

### Code Quality Standards
- **No global stylesheets** - use `ThemeManager.apply_module_style()`
- **No hardcoded paths** - use constants from `file_paths.py`
- **No direct QSettings** - use appropriate manager classes
- **No inline translations** - use `lang_manager.translate()`
- **No direct API calls** - use `APIClient`

## Common Pitfalls

### ❌ Anti-patterns to Avoid
- `QApplication.setStyleSheet()` - corrupts QGIS interface
- Direct `os.path.join()` for resources - breaks portability
- Inline English strings - not translatable
- `requests` library usage - bypasses authentication/session handling
- Direct `QSettings()` - bypasses centralized settings management

### ✅ Correct Approaches
- ThemeManager for all styling
- constants/file_paths.py for all paths
- LanguageManager for all user-facing text
- APIClient for all HTTP communication
- SettingsManager/ThemeManager for persistence

## Key Files for Understanding
- `copilot-prompt.md` - Complete detailed guidelines
- `ui/ModuleBaseUI.py` - Module architecture foundation
- `dialog.py` - Main UI orchestration
- `utils/SessionManager.py` - Authentication patterns
- `widgets/theme_manager.py` - Theming system
- `constants/file_paths.py` - Resource management
- `languages/language_manager.py` - Translation system</content>
<parameter name="filePath">c:\Users\Kalver\AppData\Roaming\QGIS\QGIS3\profiles\default\python\plugins\wild_code\.github\copilot-instructions.md